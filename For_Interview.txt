1. java singletone kiya hota hai
ChatGPT
Java mein "Singleton" ek design pattern hai jo ek class ko aise implement karta hai jismein sirf ek hi instance (object) banaya ja sake. Iska matalab hai ki, jab bhi aap us class ka object banate hain, to wo hamesha wahi ek hi object return karta hai, chahe aap kitni baar bhi us class ka constructor call karein.

Singleton pattern ka upyog jab karna hota hai jab aapko ek class ki sirf ek hi instance chahiye hoti hai, jaise ki configuration manager, logger, database connection, etc. Isse aap unnecessary object creation se bachate hain aur system resources ko optimize kar sakte hain.

Ek basic implementation ka example:

java
Copy code
public class Singleton {
    private static Singleton instance;

    // Private constructor to prevent instantiation from outside
    private Singleton() {}

    // Method to get the singleton instance
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
Is example mein, getInstance() method ke through hi ek instance banaya ja sakta hai aur wo instance sabhi calls ke liye common hoga.

2. Q - can we print something on console without using main method ?
Ans - Until java 1.6 it's possible by using static block ,but from java 1.7 onwards we can not execute java program without main method.


3. @Transient annotation in a Spring Boot project is used to indicate that a field should not be persisted to the database. This annotation is particularly useful when you have fields in your entity classes that you want to include in your Java code but don't want to store in the database.

4. Global Exception handler
Bilkul, yeh ek simple aur straightforward tarika hai global exception handling ke baare mein interview mein explain karne ke liye:

"Global exception handling ke liye, hum Spring Boot mein @ControllerAdvice annotation ka use karte hain. Isse hum ek centralized exception handler bana sakte hain jo hamare application ke saare exceptions ko handle karta hai. Hum bas ek class bana lete hain aur usko @ControllerAdvice se annotate kar dete hain. Phir us class mein @ExceptionHandler annotation ka use karke specific ya generic exceptions ko handle kar sakte hain. Jaise hi koi exception hamare code mein unhandled hoti hai, wo automatically hamare global exception handler mein route ho jati hai aur hum usko waha par handle kar sakte hain. Isse humare code clean rahta hai aur hum consistency maintain kar pate hain exception handling mein."

"For global exception handling, we use @ControllerAdvice annotation in Spring Boot. It allows us to create a centralized exception handler that deals with all exceptions in our application. We just create a class and annotate it with @ControllerAdvice. Then, within that class, we use @ExceptionHandler annotation to handle specific or generic exceptions. Whenever an exception occurs in our code without being caught, it automatically routes to our global exception handler, where we can handle it. This keeps our code clean and helps maintain consistency in exception handling."

5. Tell me top 10 error code in spring boot with meanings 

400 Bad Request: This status code indicates that the server could not understand the request due to invalid syntax.

401 Unauthorized: It means the request has not been applied because it lacks valid authentication credentials for the target resource.

403 Forbidden: The server understood the request but refuses to authorize it. This typically means the client does not have access rights to the content.

404 Not Found: This status code indicates that the server cannot find the requested resource. It is the most common error encountered while browsing the web.

405 Method Not Allowed: It means the request method is known by the server but has been disabled and cannot be used.

500 Internal Server Error: This is a generic error message indicating that something has gone wrong on the server-side, but the server could not be more specific about the error.

502 Bad Gateway: This error response means that the server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.

503 Service Unavailable: The server is currently unable to handle the request due to temporary overloading or maintenance of the server.

504 Gateway Timeout: The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI or some other auxiliary server it needed to access in order to complete the request.

505 HTTP Version Not Supported: The server does not support the HTTP protocol version used in the request.

6. achcha sune System.out.println("Hello"); is code se console per printkiya jata hai logger.info("Hello") se bhi to kiya 
fark hai dono me

To summarize, System.out.println("Hello"); bas ek simple message console per print karta hai, jabki logger.info("Hello"); logging framework ka use karta hai jo aapko zyada flexibility provide karta hai log messages ko manage karne mein.

logger.info("Hello");: Ye statement logging framework ka ek hissa hai, jaise ki logback ya log4j Spring Boot mein default logger hota hai. Ye statement ek "info" level ka log message generate karta hai. Log messages different levels (jaise ki DEBUG, INFO, WARN, ERROR) mein ho sakte hain, jo ki aapke application ke log level settings ke according console, file, ya kisi aur destination per print ho sakte hain. Iske alawa, logging framework aapko flexibility deta hai ki aap log messages ko kaise format karna chahte hain aur kis tarah se unko handle karna hai, jaise ki rotation, size limit, etc.

7. What is Interface in java
Jab aap interface define karte hain, aap sirf method signatures specify karte hain - matlab method ka naam, parameters aur return type. Ismein koi bhi method ka code nahi hota. Yeh method sirf ek declaration hota hai, jiska actual code class ke dwara provide kiya jata hai jo interface ko implement karta hai.

Method Implementation: Interface mein sirf method signatures hote hain, jabki abstract class mein method signatures ke saath-saath method ka kuch implementation bhi ho sakta hai.

Multiple Inheritance: Ek class ek hi abstract class ko extend kar sakta hai, lekin ek class multiple interfaces ko implement kar sakta hai.

Constructor: Abstract class ka constructor define kiya ja sakta hai, jabki interface mein koi constructor nahi hota.

Default Methods: Interface mein default methods define kiye ja sakte hain jinhe implementing class inherit kar sakti hai, jabki abstract class mein aisa nahi hota.

Fields: Interface mein koi bhi fields (variables) declare nahi kiye ja sakte hain, lekin abstract class mein fields declare kiye ja sakte hain.

Purpose: Interface ka main purpose hota hai ek contract provide karna, jabki abstract class ka main purpose hota hai code reuse aur inheritance provide karna.

8. Queue kiya hota hai ye bhi batao easy me 

Imagine you are standing in line at a ticket counter. The first person who arrives in line gets their ticket first and leaves. Then, the second person who joins the line gets their ticket after the first person, and the process continues in the same manner.

import java.util.LinkedList;
import java.util.Queue;

public class Main {
    public static void main(String[] args) {
        // Queue banane ke liye LinkedList ka use karte hain
        Queue<String> queue = new LinkedList<>();

        // Enqueue: Elements ko queue mein daalne ke liye add() method ka use karte hain
        queue.add("Customer 1");
        queue.add("Customer 2");
        queue.add("Customer 3");

        // Dequeue: Elements ko queue se hataane ke liye remove() method ka use karte hain
        System.out.println(queue.remove()); // Output: Customer 1
        System.out.println(queue.remove()); // Output: Customer 2
    }
}

9. Stack kiya hota hai ye bhi batao easy me 

Stack ek linear data structure hai jo Last-In-First-Out (LIFO) order ko follow karta hai, yaani jo element sabse aakhri daala gaya ho woh sabse pehle bahar nikalta hai. Is tarah se, stack kaam karta hai jaise ek stapdi ya pile, jismein aap upar se kuch bhi daal sakte hain aur upar se hi kuch bhi nikal sakte hain.

import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        // Stack banane ke liye Stack class ka use karte hain
        Stack<String> websiteHistory = new Stack<>();

        // Ek webpage visit karte hain
        websiteHistory.push("https://www.google.com");

        // Fir doosra webpage visit karte hain
        websiteHistory.push("https://www.openai.com");

        // Ab agar hum "Back" button press karte hain
        String lastVisited = websiteHistory.pop();
        System.out.println("Last visited webpage: " + lastVisited); // Output: https://www.openai.com
    }
}

10. Joins sql server

Answer:
Inner Join: Returns records jab match milta hai dono tables ke beech based on join condition.
Left Join: Returns all records from left table, aur matching records from right table.
Right Join: Returns all records from right table, aur matching records from left table.
Full Outer Join: Returns records jab match milta hai kisi bhi table se.

11. What is Spring Security?

Spring Security is a powerful and customizable authentication and access control framework provided by the Spring Framework. It is widely used in Java applications,

12. what is Authentication.

Authentication: First, the identity of the user or entity requesting access is verified through authentication mechanisms such as username/password, tokens, or biometrics.

Imagine you're logging into a website. When you enter your username and password, the website verifies the details you provided. If the details are correct, the website allows you to access it. This process is called authentication.


13. what is authorization .

Jaise, sochiye aap ek online store mein hain. Jab aap login karte hain, toh aapko sirf aapki khud ki orders dekhne ka permission hai, lekin aap dusre logon ki orders nahi dekh sakte. Yeh permissions ka system authorization kehlaya jata hai. Isse aapko sirf un features tak hi access milta hai jo aapke liye sahi hain.

14. What are the different authentication mechanisms supported by Spring Security?

Form-Based Authentication: This is the most common authentication mechanism used in web applications. It involves presenting users with a login form where they enter their credentials (username and password). Spring Security handles the submission of this form, validates the credentials, and grants access if they are correct.

HTTP Basic Authentication: In this mechanism, the client sends the username and password with each HTTP request. The credentials are encoded (not encrypted) and included in the request headers. Spring Security provides support for parsing and validating these credentials.

OAuth2 Authentication: OAuth2 is an open standard for access delegation, commonly used for enabling third-party authentication (e.g., using Google or Facebook credentials). Spring Security provides support for OAuth2 authentication, allowing applications to delegate authentication to external providers.

JWT (JSON Web Token) Authentication: JWT is a compact, URL-safe means of representing claims to be transferred between two parties. Spring Security allows for JWT-based authentication, where users are issued tokens upon successful login, and subsequent requests are authenticated using these tokens.

Custom Authentication: Spring Security provides flexibility to implement custom authentication mechanisms tailored to specific application requirements. Developers can implement custom authentication providers, filters, or handlers to authenticate users based on unique criteria or business logic.

15. Explain the role of GrantedAuthority in Spring Security

GrantedAuthority is an interface that represents a granted authority or role that a user possesses.

Each authority typically corresponds to a specific permission or role that defines what actions or resources a user can access within an application.

In summary, GrantedAuthority in Spring Security represents the roles or authorities granted to a user, determines their access rights within an application, and plays a crucial role in the authorization process by enforcing access control decisions based on the user's roles.

16. What is method-level security in Spring Security? How can you implement it?

To use method-level security, you need to enable it in your Spring Security configuration.

This is typically done by annotating your security configuration class with @EnableGlobalMethodSecurity and specifying the security annotations you want to use, such as @PreAuthorize, @PostAuthorize, etc.

Common annotations include:
@PreAuthorize: Specifies that the method can only be invoked if the specified expression evaluates to true before the method is called.
@PostAuthorize: Specifies that the method can be invoked, but the return value must meet the specified expression before it is returned to the caller.
@Secured: Specifies that the method can only be invoked by users who have been granted the specified roles or authorities.

For example, @PreAuthorize("hasRole('ROLE_ADMIN')") allows only users with the "ROLE_ADMIN" authority to invoke the annotated method.

@Service
public class MyService {

    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public void adminOperation() {
        // Method implementation accessible only to users with ROLE_ADMIN
    }
}

17. how does spring security prevent csrf atteck.

Spring Security protects against CSRF attacks using a simple method: CSRF token. This token is a unique code associated with each user's session. Whenever you submit a form or send a request to the server, your browser automatically includes the CSRF token.


18. what is the purpose of collection in java

 a collection is a framework provided by the Java API to store and manipulate groups of objects. The purpose of collections is to provide a way to manage and organize data efficiently. Collections offer several benefits:

Dynamic Size: Collections can dynamically grow or shrink in size, allowing for flexible storage of elements without needing to specify the size beforehand.

Easy Access and Manipulation: Collections provide methods to add, remove, and modify elements easily. They also offer various operations for searching, sorting, and iterating over elements efficiently.

A collection in Java is a powerful framework for managing groups of objects. It allows us to store and organize data efficiently. To illustrate this concept, consider the analogy of having a friend who holds all your necessary items in a bag. You give your friend the responsibility to manage your books and pens, so you don't have to carry them yourself. In this analogy, your friend acts as a collection, collecting and organizing your items in the bag. Similarly, a collection in Java collects and manages objects, making it easier for developers to work with groups of data."

Overall, the purpose of collections in Java is to provide a flexible, efficient, and type-safe way to manage groups of objects, making it easier for developers to work with and manipulate data in their programs.

19. Question: What is Java Servlet and how does it work?
Answer: Java Servlet is used for generating dynamic content in web applications. It is a Java program that runs on the server-side and handles HTTP requests. For example, when an HTML form is submitted, the Servlet takes the form data to the server, and the server processes that data and generates a response.

20. Question: What is the difference between Servlet and JSP?
Answer: Both Servlet and JSP are server-side technologies, but they serve different purposes. Servlet is a server-side programming language-based component that generates dynamic web pages by combining Java code with HTML. On the other hand, JSP (JavaServer Pages) allows embedding Java code within HTML, enabling us to generate dynamic web content.

21. Question: What is JDBC and how do you use it?
Answer: JDBC (Java Database Connectivity) is an API used to connect Java applications to databases and execute queries. It allows us to retrieve, insert, update, and delete data from the database. By using JDBC, we can connect to any relational database management system (RDBMS) like MySQL, Oracle, or SQL Server.

22. Question: What is Java Persistence API (JPA) and what is Hibernate's role?
Answer: Java Persistence API (JPA) is a standard for data persistence in Java applications. It provides an abstraction layer for interacting with databases. Hibernate is a popular JPA implementation that provides Object-Relational Mapping (ORM). This means we can map Java objects directly to database tables, making database interactions easier.

23. Question: What are Enterprise JavaBeans (EJB) and how do they work?
Answer: Enterprise JavaBeans (EJB) is a server-side component model used for developing distributed, transactional, and scalable applications. EJB allows us to modularize business logic into components for reusability and maintainability. It is typically used in enterprise-level applications requiring high-level security, transaction management, and concurrency control.

24. Question: What is the difference between Servlet Container and Application Server?
Answer: A Servlet Container is a part of an Application Server that manages the execution and management of Servlets and JSPs. An Application Server is a broader term that provides additional features besides Servlet Containers, such as JNDI, JMS, EJB, and distributed computing. This means a Servlet Container only supports Servlets and JSPs, while an Application Server is a complete development environment with support for various components.

25. Question: What is the difference between HashSet and TreeSet in Java?
Answer: HashSet is an unordered collection that does not allow duplicate elements, whereas TreeSet is a sorted set that stores elements in ascending order and does not allow duplicates. HashSet offers constant-time performance for the basic operations like add, remove, contains, whereas TreeSet offers log(n) time complexity for these operations as it maintains elements in a sorted order.

26. Question: Explain the concept of Generics in Java and why are they used?
Answer: Generics in Java allow us to create classes, interfaces, and methods that can operate on any type of data while providing compile-time type safety. They help in writing reusable code by allowing the creation of generic algorithms that work with different types of data. For example, a generic class like ArrayList<E> can store elements of any type, providing type safety at compile time.

27. Question: What is the difference between serialization and externalization in Java?
Answer: Serialization is the process of converting an object into a byte stream to store it in a file or send it over the network, whereas externalization is a way to customize the serialization process by implementing the Externalizable interface. Unlike serialization, externalization gives developers control over the serialization process by allowing them to define custom read and write methods for object serialization and deserialization.

28. Question: What is the Java Memory Model (JMM) and why is it important?
Answer: The Java Memory Model defines how threads interact through memory and ensures that changes made by one thread are visible to other threads. It defines the rules for memory visibility, synchronization, and atomicity in multithreaded applications. Understanding the JMM is crucial for writing correct and efficient concurrent programs in Java to avoid issues like race conditions, deadlocks, and memory inconsistencies.

29. Question: What are Lambda expressions in Java 8 and how do they work?
Answer: Lambda expressions are a feature introduced in Java 8 that allows the representation of anonymous functions in a concise and readable manner. They provide a way to pass behavior as an argument to a method, which enables functional programming paradigms in Java. Lambda expressions consist of parameters, arrow token (->), and a body, allowing the definition of inline functions without the need for anonymous inner classes.

30. Question: Explain the difference between checked and unchecked exceptions in Java.
Answer: Checked exceptions are the exceptions that are checked at compile-time, and the compiler ensures that they are handled by either catching them or declaring them in the method signature using the throws keyword. Unchecked exceptions, on the other hand, are not checked at compile-time, and the compiler does not force the developer to handle them explicitly. Unchecked exceptions are subclasses of RuntimeException and Error, while checked exceptions are all other exceptions.

31. What is the difference between composition and inheritance in Java?

Composition:
Composition is like building something using smaller parts. In Java, it means creating a new class by including objects of other classes as its member variables. It's like assembling Lego blocks to create something new. For example, if you have a Car class and a Engine class, you can compose a Car object by including an Engine object inside it.

// Engine class representing a car engine
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

// Car class composed of an Engine object
class Car {
    private Engine engine; // Composition

    Car() {
        this.engine = new Engine();
    }

    void startCar() {
        engine.start(); // Delegating start operation to Engine object
        System.out.println("Car started");
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.startCar(); // Output: Engine started, Car started
    }
}


Difference:
The main difference is in how new classes are created. With composition, you create a new class by including objects of other classes, while with inheritance, you create a new class by extending an existing class. Composition allows for more flexible and loosely coupled designs, while inheritance can lead to tight coupling and potential issues with the class hierarchy.
in dono ka ek example batana

32. what is Abstract class.

An abstract class in Java is a class that cannot be instantiated on its own and may contain abstract methods (methods without a body). Abstract classes are designed to be extended by other classes. They provide a way to define a blueprint for other classes to follow. Abstract classes can contain both abstract methods (which must be implemented by the subclass) and concrete methods (with an implementation).

Here's a summary of the key points regarding abstract classes:

You cannot create an instance of an abstract class using the new keyword.
Abstract classes can have constructors, fields, and methods.
Abstract methods declared in an abstract class must be implemented by the subclass (non-abstract subclass).
Abstract classes are used when you want to provide a common interface for a group of related classes, but you don't want to provide a complete implementation.













+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+
1. What is Docker?
Docker is a platform that allows you to develop, deploy, and run applications in containers. Containers are lightweight, portable, and self-sufficient environments that package everything needed to run an application, including libraries and dependencies.

2. What is the difference between Docker container and virtual machine (VM)?
Docker containers share the host operating system kernel, while virtual machines run their own operating system kernel. This makes containers more lightweight and efficient compared to VMs.

3. How do you create a Docker container?
You can create a Docker container by writing a Dockerfile, which contains instructions for building the container image. Once the Dockerfile is written, you use the docker build command to build the image, and then the docker run command to run the container.

4. What is a Docker image?
A Docker image is a read-only template that contains the instructions for creating a Docker container. It includes everything needed to run an application, such as code, runtime, libraries, and dependencies.

5. How do you share Docker images with others?
Docker images can be shared via Docker Hub, a cloud-based registry service provided by Docker. You can push your images to Docker Hub using the docker push command, and others can pull them using the docker pull command.

6. What is Docker Compose?
Docker Compose is a tool for defining and running multi-container Docker applications. It uses a YAML file to configure the application's services and dependencies, making it easy to define, run, and manage complex applications.

7. How do you scale Docker containers?
Docker containers can be scaled horizontally by running multiple instances of the same container across multiple hosts. Docker Swarm and Kubernetes are popular tools for orchestrating and managing containerized applications at scale.

8. What is Docker Swarm?
Docker Swarm is a native clustering and orchestration tool for Docker containers. It allows you to create and manage a cluster of Docker hosts, called a swarm, and deploy and scale applications across the swarm.

9. What is Docker volume?
Docker volume is a persistent data storage mechanism that allows containers to store data outside the container's writable layer. Volumes can be shared between containers and persist even after the container is stopped or removed.

10. How do you monitor Docker containers?
Docker provides several built-in tools for monitoring containers, including Docker Stats, Docker Events, and Docker Logs. Additionally, there are third-party monitoring solutions and container orchestration platforms like Kubernetes that offer advanced monitoring and logging capabilities.


+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+_+

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Resume Interview Questions with Answer

Technical Questions
Core Java Concepts

Differences between Java 7, 8, and 11:

Java 7: Introduced features like the try-with-resources statement, catch multiple exceptions, and the Diamond operator.
Java 8: Introduced lambdas, the Stream API, new Date and Time API, and default methods in interfaces.
Java 11: Introduced local variable syntax for lambda parameters, HTTP Client API, and removed Java EE and CORBA modules.
Main features of Java 8:

Lambdas, Stream API, new Date and Time API, default methods in interfaces, and Nashorn JavaScript Engine.
Object-oriented programming principles:

Inheritance: Mechanism for a new class to use properties and methods of an existing class.
Polymorphism: Ability of different classes to respond to the same method call in different ways.
Encapsulation: Bundling of data with methods that operate on that data.
Abstraction: Hiding the complex implementation details and showing only the essential features of an object.
Spring Framework

Core components of Spring Boot:

Spring Boot Starter: Simplifies the dependency management.
Spring Boot Auto Configuration: Automatically configures Spring application based on the dependencies.
Spring Boot Actuator: Provides production-ready features like monitoring and metrics.
Managing dependencies in Spring Boot:

Use spring-boot-starter dependencies in pom.xml or build.gradle to easily manage the required libraries.
How Spring Security works:

Provides authentication and authorization features, can be configured using annotations or XML, supports various authentication mechanisms like in-memory, LDAP, and database authentication.
Spring Data JPA:

Simplifies database operations by providing a repository layer, reducing boilerplate code for CRUD operations and queries.
RESTful Web Services

RESTful web services principles:

Statelessness, client-server architecture, resource representation, and using standard HTTP methods (GET, POST, PUT, DELETE).
Creating a RESTful service with Spring Boot:

Use @RestController for defining controllers, @RequestMapping for mapping URLs to methods, and @ResponseBody for returning responses.
Advantages of REST over SOAP:

REST is lightweight, easier to implement, and uses standard HTTP methods, while SOAP is more rigid and requires more overhead.
SQL and Databases

Optimizing a query in SQL Server:

Use indexes, avoid unnecessary columns in SELECT, use appropriate joins, and analyze the query execution plan.
Handling transactions in Spring:

Use @Transactional annotation to manage transactions, ensuring data integrity and rollback in case of errors.
Using MySQL or SQL Server to solve a problem:

Example: Optimized an e-commerce platform by using indexed queries to speed up product search and improve user engagement.
Microservices and Docker

Microservices vs. monolithic architectures:

Microservices break down applications into small, independent services, while monolithic architectures use a single unified codebase.
Containerizing a Java application using Docker:

Create a Dockerfile, use a base image (e.g., openjdk), copy application JAR, and define entry points to run the application.
Managing microservices in production:

Use tools like Kubernetes for orchestration, monitoring with Prometheus, and logging with ELK stack.
Tools and Technologies

Using Git and GitHub:

Git for version control, creating branches, merging code, and GitHub for repository hosting and collaboration.
Using Postman for testing APIs:

Create requests, set parameters, and validate responses for API testing.
Experience with IntelliJ IDEA or Eclipse:

Use for code writing, debugging, and managing dependencies in Java projects.
Behavioral and Situational Questions
Problem-Solving and Projects

Challenging project:

Developed a scalable e-commerce platform, overcame challenges in performance optimization, resulting in increased user engagement.
Troubleshooting a difficult issue:

Debugged a complex issue in the HR module, identified a database bottleneck, and optimized queries to improve performance.
Team Collaboration

Handling conflicts:

Addressed conflicts by facilitating open communication, understanding different perspectives, and finding common ground for resolution.
Mentoring a junior developer:

Provided guidance on coding practices, conducted code reviews, and encouraged continuous learning through pair programming.
Work Ethic and Adaptability

Staying updated:

Regularly read technical blogs, participate in online courses, and attend tech meetups and webinars.
Learning new technology:

Quickly learned Docker and implemented containerization for microservices, enhancing deployment efficiency.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++








-------------------------------- How to upload project on github ---------------------------------
git config core.autocrlf false
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/mdrashid786/spring-security-mvc.git
git push -u origin main

…or push an existing repository from the command line
git remote add origin https://github.com/mdrashid786/demoSecurity.git
git branch -M main
git push -u origin main



-------------------------------------------------------------------------------------------------

docker image create cammand

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
this this project file code : file name is dockerfile without any extention 
FROM node
COPY . .
RUN npm install
EXPOSE 5000
CMD [ "node", "index.js" ]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

--------------------------------------------------for docker operation ----------------------------------------------------
create image coammand from terminal
docker build -t basic_application .

check how many images are available
docker images

check how many container are available 
docker ps -a

how to delete image
docker image rm  basic_application1

if image is in-used then delete image using this cammand
docker image rm  basic_application1 -f

how to delete container 
docker container rm jatin

if container is in running the use this cammand for delete
docker container rm jatin -f

delete all image or conatainer 
docker system prune -a

how to create image with vaersion
docker build -t imageName:version
example 
docker build -t my-new-image:v2 .

run conatiner from cmd
docker run --name conatinerName -p newPort:alreadyaxistPort alreadyAxistimageName
example 
docker run --name basic-new-app-container--v2 -p 5000:5000 my-new-image:v2

run project on docker container to update if any changes from user side 
 this bottom code is for dockerfile

FROM node:latest
# Install nodemon globally
RUN npm install -g nodemon
# Set working directory
WORKDIR /app
# Copy package.json and install dependencies first (better for caching)
COPY package.json package-lock.json ./
RUN npm install
# Copy the rest of the application
COPY . .
# Expose the desired port
EXPOSE 5000
# Use npm run dev to start the application, enabling polling for file changes
CMD ["npm", "run", "dev"]

and this code for Package.json file 

{
  "name": "basic-app",
  "version": "1.0.0",
  "description": "docker tutorial",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon --legacy-watch index.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.19.2",
    "nodemon": "^3.1.0"
  }
}

after added this all then first create Image 
docker build -t my-application .
after created Image then run this image in bottom code is running for docker container cammand
docker run --name my-app-container -p 5000:5000 --rm -v C:\Users\pc\Videos\basic-app:/app -e CHOKIDAR_USEPOLLING=true my-application
after that i project is started on docker conatainer
then if you changes anythings then automatically changes on docker container file you can check on live by refresh url 


and this given bottom code is for local to run project 
npm run dev

and this 2nd step to run on docker conatiner :
this dockerfile code

FROM node:latest
RUN npm install -g nodemon
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 5000
CMD [ "npm","run","dev" ]

and this is Package.json code
{
  "name": "basic-app",
  "version": "1.0.0",
  "description": "docker tutorial",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev":"nodemon index.js"
 
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.19.2",
    "nodemon": "^3.1.0"
  }
}

and this is cammand to run on docker conatainer server
docker run --name my-app-container -p 5000:5000 --rm -v C:\Users\pc\Videos\basic-app:/app -e CHOKIDAR_USEPOLLING=true my-application

create compose cammand
create first compose.yaml file 
and write this code inside yaml file
services:
  img:
   build: .
   container_name: basic-container
   ports:
    - 5000:5000

after that hit this bottom cammand
docker compose up

share image on docker hub and push image on docker hub
first create repository on hub.docker.com
after that copy repository name
this is my repository name mdrashid00/node-yt-app
after that create image from vs code terminal 
cammand is  docker build -t mdrashid00/node-yt-app .
and then check you login or not by using this cammand 
docker login
after that push your image on docker hub cammand is this in bottom
docker push pasteYourHubDockerRepositoryName
Example 
docker push mdrashid00/node-yt-app

and push repository
then pull repository
first open hub.docker.com then click on tags tab and then copy pull cammand from right side 
cammand is : docker pull mdrashid00/node-yt-app:latest
and this hit this cammand in vs code terminal
docker pull mdrashid00/node-yt-app:latest
after that open docker deshtop and run your new image 

upload image on server | play-with-docker 
first create repo on hub.docker.com 
after that create image using this cammand
docker buildx build --platform linux/amd64 -t mdrashid00/node-demo-app .
after that push container same as previous 
docker push mdrashid00/node-demo-app
after push code then go to play with docker website
url : https://labs.play-with-docker.com/
after login with docker account on play with docker website
after that again on hub.docker.com website and then copy pull cammand 
and then create instance on play with docker website
and page pull cammand in play-with-docker website cmd
docker pull mdrashid00/node-demo-app
after finish pull then you can check image avalaible or not by using this cammand 
docker images
after that run image by using thus cammand 
docker run -p 5000:5000 mdrashid00/node-demo-app
after that click on top on port no now see your application is live


---------------------------------------------end here docker operation --------------------------------------------------------

PS C:\Users\pc\Videos\basic-app> npm init
This utility will walk you through creating a package.json file.    
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (basic-app) npm init
Sorry, name can only contain URL-friendly characters.
package name: (basic-app)
version: (1.0.0)
description: docker tutorial
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to C:\Users\pc\Videos\basic-app\package.json:

{
  "name": "basic-app",
  "version": "1.0.0",
  "description": "docker tutorial",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

Is this OK? (yes) yes
npm notice 
npm notice New minor version of npm available! 10.1.0 -> 10.8.0
npm notice Changelog: https://github.com/npm/cli/releases/tag/v10.8.0
npm notice Run npm install -g npm@10.8.0 to update!
npm notice
PS C:\Users\pc\Videos\basic-app> npm i express

added 64 packages, and audited 65 packages in 5s

12 packages are looking for funding
  run `npm fund` for details
found 0 vulnerabilities
PS C:\Users\pc\Videos\basic-app> npm index.js
Unknown command: "index.js"

To see a list of supported npm commands, run:
  npm help
PS C:\Users\pc\Videos\basic-app> node index.js
app is running on 5000 port
PS C:\Users\pc\Videos\basic-app> node index.js
touch : The term 'touch' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was
included, verify that the path is correct and try again.
At line:1 char:1
+ touch dockerFile
+ ~~~~~
    + CategoryInfo          : ObjectNotFound: (touch:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException

operable program. Check the spelling of the name, or if a path was included, verify that the path                                       function, script file, or
is correct and try again.                                           ncluded, verify that the path
At line:1 char:1
+ touch dockerfile
+ ~~~~~
    + CategoryInfo          : ObjectNotFound: (touch:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException

PS C:\Users\pc\Videos\basic-app> docker build -t basic-app .
[+] Building 7.9s (8/8) FINISHED                                                                                                                       docker:default
 => [internal] load build definition from dockerfile                                                                                                             0.1s
 => => transferring dockerfile: 114B                                                                                                                             0.0s
 => [internal] load metadata for docker.io/library/node:latest                                                                                                   0.0s
 => [internal] load .dockerignore                                                                                                                                0.1s
 => => transferring context: 2B                                                                                                                                  0.0s
 => [internal] load build context                                                                                                                                0.7s
 => [1/3] FROM docker.io/library/node:latest                                                                                                                     0.7s 
 => [2/3] COPY . .                                                                                                                                               1.1s 
 => [3/3] RUN npm install                                                                                                                                        5.3s 
 => exporting to image                                                                                                                                           0.3s 
 => => exporting layers                                                                                                                                          0.1s 
 => => writing image sha256:d61539a339b4b5cd71f4564c0d16f8311e87892ddf28a4ca8bcc40996aff194b                                                                     0.0s 
 => => naming to docker.io/library/basic-app                                                                                                                     0.0s 

View build details: docker-desktop://dashboard/build/default/default/nuc8cjcnfwahvbjbv1mg37h2x

What's Next?
  View a summary of image vulnerabilities and recommendations → docker scout quickview
PS C:\Users\pc\Videos\basic-app> node index.js
node:events:492
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE: address already in use :::5000
    at Server.setupListenHandle [as _listen2] (node:net:1872:16)
    at listenInCluster (node:net:1920:12)
    at Server.listen (node:net:2008:7)
    at Function.listen (C:\Users\pc\Videos\basic-app\node_modules\express\lib\application.js:635:24)
    at Object.<anonymous> (C:\Users\pc\Videos\basic-app\index.js:28:5)
    at Module._compile (node:internal/modules/cjs/loader:1241:14)
    at Module._extensions..js (node:internal/modules/cjs/loader:1295:10)
    at Module.load (node:internal/modules/cjs/loader:1091:32)
    at Module._load (node:internal/modules/cjs/loader:938:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:83:12)
Emitted 'error' event on Server instance at:
    at emitErrorNT (node:net:1899:8)
    at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {
  code: 'EADDRINUSE',
  errno: -4091,
  syscall: 'listen',
  address: '::',
  port: 5000
}

Node.js v20.9.0
PS C:\Users\pc\Videos\basic-app> 
